
#include "compiler.hpp"

static const size_t BAD_REG_ID_ = 0xFFFF;

/* for all asserts */
#define ASSERTS( CMPLP_, NODEP_, BUFF_ ) \
{                                        \
    assert (!isBadPtr (CMPLP_));         \
    assert (!isBadPtr (NODEP_));         \
    assert (!isBadPtr (BUFF_ ));         \
}

/* all asm strings in one place - for simple syntax change */
    #define _ASM_PROC_BODY_TAB "            "

    #define _ASM_PROC_DECL                      "    PROC"
    #define _ASM_PROC_END                       "ENDP"

    #define _ASM_INPUT      _ASM_PROC_BODY_TAB  "IN    "
    #define _ASM_OUTPUT     _ASM_PROC_BODY_TAB  "OUT   "
    #define _ASM_POP        _ASM_PROC_BODY_TAB  "POP   "
    #define _ASM_PUSH       _ASM_PROC_BODY_TAB  "PUSH  "
    #define _ASM_CMPSTK     _ASM_PROC_BODY_TAB  "CMPS  "
    #define _ASM_POPALL     _ASM_PROC_BODY_TAB  "POPA  "
    #define _ASM_PUSHALL    _ASM_PROC_BODY_TAB  "PUSHA "
    #define _ASM_CALL       _ASM_PROC_BODY_TAB  "CALL  "
    #define _ASM_RET        _ASM_PROC_BODY_TAB  "RET   "
    #define _ASM_MOV        _ASM_PROC_BODY_TAB  "MOV   "
    #define _ASM_EXIT       _ASM_PROC_BODY_TAB  "EXIT  "
    #define _ASM_JE         _ASM_PROC_BODY_TAB  "JE    "
    #define _ASM_JMP        _ASM_PROC_BODY_TAB  "JMP   "

Err_t putTree( Compiler* cmplp, const char* const out_name )
{
    assert (!isBadPtr (cmplp));
    assert (!isBadPtr (out_name));

/* max number of symbols that can be generated by one tree node (child nodes symbols are not included) */
    const size_t ONE_NODE_MAX_SYMBOLS_NUM_ = 100;

/* allocating memory for out buffer */
    char* out_buff = (char* )calloc (ONE_NODE_MAX_SYMBOLS_NUM_, cmplp->tree_.size_);
    if (out_buff == nullptr) return cmplp->error_info_.error_ = MEM_ERR_;

/* translating tree to out buffer */
    size_t  buff_shift = 0;
    size_t  additional_shift = 0;
    node_t* funcs_nodep = cmplp->tree_.root_;

    cmplp->last_func_id_ = 0;

/* placing functions until there is no functions LRs left */
    while (funcs_nodep->data.type != IDENT_)
    {
        additional_shift = putFunc (cmplp, funcs_nodep->left_ch, out_buff + buff_shift);
        if (cmplp->error_info_.error_ != OK_)
        {
            free (out_buff);
            return cmplp->error_info_.error_;
        }

        buff_shift += additional_shift;
        funcs_nodep = funcs_nodep->righ_ch;
        cmplp->last_func_id_++;
    }

/* placing last function */
    additional_shift = putFunc (cmplp, funcs_nodep, out_buff + buff_shift);
    if (cmplp->error_info_.error_ != OK_)
    {
        free (out_buff);
        return cmplp->error_info_.error_;
    }

    buff_shift += additional_shift;

/* out file open */
    FILE* out_filep = fopen (out_name, "wb");
    if (out_filep == nullptr)
    {
        free (out_buff);
        return FILE_ERR_;
    }

/* writting data & closing all */
    fwrite (out_buff, sizeof (char), buff_shift, out_filep);
    fclose (out_filep);
    free   (out_buff);

    return OK_;
}

size_t putFunc( Compiler* cmplp, const node_t* nodep, char* buff )
{
    ASSERTS (cmplp, nodep, buff);

    /* for arguments parce */
    node_t* argp = nodep->left_ch;

    /* getting all arguments in names list */
    for (cmplp->last_var_id_ = 0; cmplp->last_var_id_ < NUMOF_VARS_; ++(cmplp->last_var_id_))
    {
        if (argp == nullptr) break;

        cmplp->variables_[cmplp->last_var_id_][0] = (argp->data.data.name)[0];
        cmplp->variables_[cmplp->last_var_id_][1] = (argp->data.data.name)[1];

        argp = argp->left_ch;
    }

    size_t buff_shift = 0;
    size_t additional_shift = 0;

    /* func head */
    buff_shift = sprintf (buff,
                          "%.16s" _ASM_PROC_DECL "\n\n",
                          nodep->data.data.name);

    /* func body */
    additional_shift = putLR (cmplp, nodep->righ_ch, buff + buff_shift);
    if (cmplp->error_info_.error_ != OK_) return 0;

    buff_shift += additional_shift;

    /* func end */
    buff_shift += sprintf (buff + buff_shift,
                           "\n"
                           _ASM_PROC_END "\n\n");

    return buff_shift;
}

size_t putLR( Compiler* cmplp, const node_t* nodep, char* buff )
{
    ASSERTS (cmplp, nodep, buff);

    /* asm buffer shift */
    size_t buff_shift = 0;
    /* variable id - if needed */
    int varId = 0;

    /* for simple access */
      /* root node of LR branch body */
        node_t* lrBody = nodep->left_ch;
      /* next LR */
        node_t* lrNext = nodep->righ_ch;

    /* empty lr is ok */
    if (lrBody != nullptr)
    {
        /* LR body root data */
        data_t  lrData = lrBody->data;

        switch (lrData.type)
        {
            case KEY_:
                switch (lrData.data.name [0])
                {
                    /* there is special function for this complicated constructions */
                    case KEY_WHILE_[0]  :
                    case KEY_BREAK_[0]  :
                    case KEY_IF_[0]     :
                    case KEY_RETURN_[0] :
                        buff_shift = putConstr (cmplp, lrBody, buff);
                        break;

                    /* special syntaxis here */
                    case KEY_INPUT_[0] :
                    case KEY_OUTPUT_[0]:
                        varId = getVarId (cmplp, lrBody->left_ch->data.data.name);
                        if (varId == BAD_REG_ID_)
                        {
                            cmplp->error_info_ = { SYNT_ERR_, lrData.location };
                            return 0;
                        }

                        if (lrData.data.name [0] == KEY_INPUT_[0])
                            buff_shift += sprintf (buff, _ASM_INPUT  "R%02X", varId);
                        else
                            buff_shift += sprintf (buff, _ASM_OUTPUT "R%02X", varId);

                        break;

                    /* just need to remember new name */
                    case KEY_VAR_DEC_[0]:
                        if (cmplp->last_var_id_ == NUMOF_VARS_)
                        {
                            cmplp->error_info_ = { SYNT_ERR_, lrData.location };
                            return 0;
                        }

                        if (getVarId (cmplp, lrBody->left_ch->data.data.name) != BAD_REG_ID_)
                        {
                            cmplp->error_info_ = { SYNT_ERR_, lrData.location };
                            return 0;
                        }

                        cmplp->variables_[cmplp->last_var_id_  ][0] = (lrBody->left_ch->data.data.name)[0];
                        cmplp->variables_[cmplp->last_var_id_++][1] = (lrBody->left_ch->data.data.name)[1];

                        break;

                    /* putting expression */
                    default:
                        buff_shift = putExpr (cmplp, lrBody, buff);
                        if (cmplp->error_info_.error_ != OK_) return 0;
                        
                        buff_shift += sprintf (buff + buff_shift, _ASM_POP "\n");

                        break;
                }

                break;

            /* putting call */
            case IDENT_:
                buff_shift = putCall (cmplp, lrBody, buff);
                break;

            /* can't be! */
            default:
                cmplp->error_info_ = { SYNT_ERR_, lrData.location };

                return 0;
        }
    }

    size_t rec_buff_shift = 0;

    /* placing next LRs */
    if (lrNext != nullptr)
    {
        if (buff_shift != 0)
            buff_shift += sprintf (buff + buff_shift, "\n");

        rec_buff_shift = putLR (cmplp, lrNext, buff + buff_shift);
        if (cmplp->error_info_.error_ != OK_) return 0;
    }

    return buff_shift + rec_buff_shift;
}

size_t putCall( Compiler* cmplp, const node_t* nodep, char* buff )
{
    ASSERTS (cmplp, nodep, buff);

    size_t buff_shift = 0;
    size_t additional_shift = 0;

    /* curr func argument pointer */
    node_t* argp = nodep->left_ch;

    /* arguments counter */
    size_t arg_cnt = 0;

    buff_shift = sprintf (buff, _ASM_PUSHALL "\n");

    /* arguments send */
    for (; arg_cnt < NUMOF_VARS_; ++arg_cnt)
    {
        if (argp == nullptr) break;

        int reg_id = getVarId (cmplp, argp->data.data.name);
        if (reg_id == BAD_REG_ID_)
        {
            cmplp->error_info_ = { SYNT_ERR_, argp->data.location };
            return 0;
        }

        buff_shift += sprintf (buff + buff_shift,
                               _ASM_MOV "R%02lX R%02X" "\n",
                               arg_cnt, reg_id);

        buff_shift += additional_shift;

        argp = argp->left_ch;
    }

    /* call */
    buff_shift += sprintf (buff + buff_shift,
                           _ASM_CALL "%.16s" "\n",
                           nodep->data.data.name);

    /* registers restoration */
    buff_shift += sprintf (buff + buff_shift,
                           _ASM_POPALL       "\n"
                           _ASM_PUSH   "R07" "\n");

    return buff_shift;
}

size_t putConstr( Compiler* cmplp, const node_t* nodep, char* buff )
{
    ASSERTS (cmplp, nodep, buff);

    /* to count buff shift */
    size_t buff_shift = 0;
    /* to get shifts on each step */
    size_t additional_shift = 0;

    NamePart_t nodeNameFtPart = nodep->data.data.name [0];

    switch (nodeNameFtPart)
    {
        /* return value counting & returning */
        case KEY_RETURN_[0]:

        {
            buff_shift += putExpr (cmplp, nodep->left_ch, buff);
            
            if (cmplp->last_func_id_ == 0)
                buff_shift += sprintf (buff + buff_shift,
                                       _ASM_EXIT "\n");
            else
            {
                buff_shift += sprintf (buff + buff_shift,
                                       _ASM_POP "R07" "\n"
                                       _ASM_RET       "\n");
            }
        }
        break;

        case KEY_WHILE_[0]:
        case KEY_IF_[0]:

        {
            /* curr label id for jumps */
            size_t label_id = cmplp->last_label_id_++;

            /* placing repead label for while */
            if (nodeNameFtPart == KEY_WHILE_[0])
                buff_shift = sprintf (buff,
                                      "w%04ld :" "\n",
                                      label_id);

            /* placing condition & condition check */
            additional_shift = putExpr (cmplp, nodep->left_ch, buff + buff_shift);
            if (cmplp->error_info_.error_ != OK_) return 0;
            buff_shift += additional_shift;

            buff_shift += sprintf (buff + buff_shift,
                                   _ASM_PUSH   "0"       "\n"
                                   _ASM_CMPSTK           "\n"
                                   _ASM_JE     "e%04ld"  "\n",
                                   label_id);


            /* to remember old break lable id */
            int old_break_label_id_ = cmplp->break_label_id_;

            if (nodeNameFtPart == KEY_WHILE_[0])
                cmplp->break_label_id_ = label_id;

            /* placing body */
            additional_shift = putLR (cmplp, nodep->righ_ch, buff + buff_shift);
            if (cmplp->error_info_.error_ != OK_) return 0;

            buff_shift += additional_shift;

            /* jumping back if it's cycle */
            if (nodeNameFtPart == KEY_WHILE_[0])
            {
                buff_shift += sprintf (buff + buff_shift,
                                       _ASM_JMP "w%04ld" "\n",
                                       label_id);

                /* restore old break label id */
                cmplp->break_label_id_ = old_break_label_id_;
            }

            /* condition failed label */
            buff_shift += sprintf (buff + buff_shift,
                                   "e%04ld :" "\n",
                                   label_id);
        }
        break;

        case KEY_BREAK_[0]:

        {
            /* getting break label id */
            int break_label_id = cmplp->break_label_id_;

            /* no unexit cycles => error */
            if (break_label_id == -1)
            {
                cmplp->error_info_ = { SYNT_ERR_, nodep->data.location };
                return 0;
            }

            /* jumping to exit lable */
            else
                buff_shift += sprintf (buff + buff_shift,
                                       _ASM_JMP "e%04d" "\n",
                                       break_label_id);
        }
        break;

        default:
            assert (0);
    }

    return buff_shift;
}

size_t putExpr( Compiler* cmplp, const node_t* nodep, char* buff )
{
    ASSERTS (cmplp, nodep, buff);

    size_t buff_shift = 0;
    size_t additional_shift = 0;

    switch (nodep->data.type)
    {
        /* just pushing value to stack */
        case NUM_:

        {
            buff_shift = sprintf (buff,
                                  _ASM_PUSH "%d" "\n",
                                  nodep->data.data.number);
        }
        break;

        /* call or variable value */
        case IDENT_:

        {
            if (nodep->righ_ch != nullptr)
                buff_shift = putCall (cmplp, nodep, buff);
            else
            {
                int var_id = getVarId (cmplp, nodep->data.data.name);
                if (var_id == BAD_REG_ID_)
                {
                    cmplp->error_info_ = { SYNT_ERR_, nodep->data.location };
                    return 0;
                }

                buff_shift = sprintf (buff,
                                      _ASM_PUSH "R%02X" "\n",
                                      var_id);
            }
        }
        break;

        case KEY_:

        {
            /* special operation */
            if (!nameCmpr (nodep->data.data.name, KEY_ASSIGN_))
            {
                int var_id = getVarId (cmplp, nodep->left_ch->data.data.name);
                if (var_id == BAD_REG_ID_)
                {
                    cmplp->error_info_ = { SYNT_ERR_, nodep->left_ch->data.location };
                    return 0;
                }

                buff_shift = putExpr (cmplp, nodep->righ_ch, buff);
                if (cmplp->error_info_.error_ != OK_) return 0;

                buff_shift += sprintf (buff + buff_shift,
                                       _ASM_POP  "R%02X" "\n"
                                       _ASM_PUSH "R%02X" "\n",
                                       var_id, var_id);
            }

            /* putting expr for child nodes & then use their results to produce own result */
            else
            {
                buff_shift = putExpr (cmplp, nodep->left_ch, buff);
                if (cmplp->error_info_.error_ != OK_) return 0;

                additional_shift = putExpr (cmplp, nodep->righ_ch, buff + buff_shift);
                if (cmplp->error_info_.error_ != OK_) return 0;

                buff_shift += additional_shift;

                switch (nodep->data.data.name[0])
                {
                    #define DEF_KEY( NAME_, CODE1_, CODE2_, OPRS_, ASM_NAME_ )  \
                    case CODE1_:                                                \
                        buff_shift += sprintf (buff + buff_shift,               \
                                               _ASM_PROC_BODY_TAB "%.16s" "\n", \
                                               ASM_NAME_);                      \
                        break;

                    #include "DSL_KEY.h"

                    #undef DEF_KEY
                }
            }
        }
        break;

        default:
            assert (0);

    }

    return buff_shift;
}

int getVarId( const Compiler* cmplp, const NamePart_t name[2] )
{
    for (int var_id = 0; var_id < cmplp->last_var_id_; var_id++)
    {
        if (!nameCmpr (cmplp->variables_[var_id], name))
            return var_id;
    }

    return BAD_REG_ID_;
}

/* undefs */
    #undef _ASM_PROC_BODY_TAB

    #undef _ASM_PROC_DECL
    #undef _ASM_PROC_END
    #undef _ASM_INPUT
    #undef _ASM_OUTPUT
    #undef _ASM_POP
    #undef _ASM_PUSH
    #undef _ASM_CMPSTK
    #undef _ASM_POPALL
    #undef _ASM_PUSHALL
    #undef _ASM_RET
    #undef _ASM_CALL
    #undef _ASM_MOV
    #undef _ASM_EXIT
    #undef _ASM_JE
    #undef _ASM_JMP